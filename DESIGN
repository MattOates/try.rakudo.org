[[ TODO:
  - think about race-conditions involving busy-flag
    possible solution: single-threaded backend? non-blocking io?
  - bug sorear about adding partial reads to IO::Pty::HalfDuplex
]]

--- Frontend ---

The client communicates with the server through 3 HTTP addresses. The Apache
rewrite engine is used to call corresponding perl scripts:

  /        --> /cgi/shell.pl
  /send    --> /cgi/send.pl
  /receive --> /cgi/receive.pl

The last 2 addresses are only used internally and shouldn't be called by the
user.

All addresses take a 64bit session-id in hexadecimal notation as query-string.
A user-visible address would be of the form

  http://try.rakudo.org/?6e74656e352f636f

This address can be used to bookmark the output of an expired sessions or
passed around to allow collaboration on active sessions.

The three scripts perform the following actions:

Script shell.pl
This script is responsible for sending the HTML document to the client. The
expected request type is GET.
If no session-id is provided, a new session will be created. This involves
adding an entry to the Sessions table, querying for its sid, choosing an unused
TCP port and starting a new backend process. The hexadecimal session-id
notation is the result of xor-ing the sid value with a masking constant, which
is necessary to avoid tempting the user to manually generate session-ids by
incrementing existing ones. A 30x response navigates the client to / with the
session-id appended.
If a session-id is provided, the DB is queried for the state of the session and
all entries in the Messages table belonging to this id. The messages will be
written to the output area of the HTML document. If the session is busy or
expired, the user input elements will be disabled.
[[ If the session is busy and not expired, a Refresh header-field could be
sent. This would trigger an automatic page reload to allow using the shell
without client-side scripting. If this is not done, the user will have to
manually refresh the page to get the results of long-running computations.
The problem is that if client-side scripting is available, a Refresh field must
not be sent, which means adding logic to detect client-side scripting, possibly
involving cookies. Personally, I think requiring users which purposefully
disable Javascript to hit F5 if they triggered a long-running computation is
acceptable, as the scripting-free version should be considered a bonus anyway.
]]

Script send.pl
This script relays user input to the backend. The expected request type is
POST, with a mandatory parameter named 'cmd' containing the user input and
an optional parameter named 'js', which signifies that client-side scripting is
available. The request will be generated by an HTML form. The session-id should
be available.
If the session is not expired, a TCP connection to the backend has to be 
established and the user input transferred.
If client-side scripting is available, a 204 response prevents the page from
reloading. No data will be transferred as the backend output will be received
via client-side polling.
If client-side scripting is not available, a 30x response navigates the client
to /, which in turn reads the output from the DB. [[ If the output is not yet
ready, a manual reload is necessary, as discussed above. ]]

Script receive.pl
This script gets new output from the DB if client-side scripting is available.
The expected request type is POST and the entity body should contain the id of
the last received output message. The session-id should be available. The
request will be generated by a client-side script.
The script queries the Messages table for all messages with an mid greater
than the id provided with the request. If the session is expired or not busy,
a 200 response containing the messages and the mid of the last message will
be sent to the client. The mid can be contained in a proptietary X- HTTP header
field, which makes additional client-side parsing of the response body
unnecessary. If the session is not expired and busy, a 200 response containing
the messages and the last mid is sent as well, but a Refresh header-field will
be added. This will be detected by the client, which will spawn a new
request to get the remaining output (if no Refresh header is sent, the session
is not busy and the client can re-enable the user input fields). If no new
messages are available in the DB, the script will wait for a time and query the
DB again, possibly repeatedly until new messages are available, the session is
no longer busy or the connection to the client has been closed.

--- Backend ---

[[ This is a draft ]]

The backend is responsible for transferring messages between the frontend and
the rakudo instance as well as managing rakudo.

The frontend will provide the sid of the session and a port on which the
backend listends for TCP connections on creation of the backend.

If blocking IO is used, 2 threads are necessary:
The first one listens for TCP connections from the frontend. If a socket is
available, its data will be piped to the rakudo process as well as
added with a '> '-prefix to the Messages table. The busy-flag will be set.
The second thread listens for rakudo output and writes it to the DB. If rakudo
has no more output to produce (ie when it blocks on user input, which can be
detected with IO::Pty::HalfDuplex thanks to sorear++), the busy_flag will
be unset.

The backend also needs to decide when to terminate rakudo. Possible indicators
are a maximal lifetime, the last-access and last-message field in the Sessions
table, the number of messages or the total size of the produced output.

--- Database ---

All access to session data should set the last-access field. The DB should be
periodically cleaned by comparing last-access against the current datetime.

Table Sessions
Fields:
  - sid : uint64, unique, auto-increment
  - backend-port : uint16
  - state : char // a - active, b - busy, x - expired
  - creation-time : timestamp
  - last-access : timestamp
  - last-message : timestamp
Key: sid

Table Messages
Fields:
  - sid : uint64
  - mid : uint32
  - contents : text
Key: sid + mid
